import path from 'path';
import fs from 'fs/promises';

export interface EmbedOptions {
  /** Width of the embed (default: '100%') */
  width?: string | number;
  /** Height of the embed (default: 'auto' for video tag, '400' for iframe) */
  height?: string | number;
  /** Autoplay the video (default: false) */
  autoplay?: boolean;
  /** Loop the video (default: false) */
  loop?: boolean;
  /** Mute the video (default: false for video tag, true if autoplay) */
  muted?: boolean;
  /** Show video controls (default: true) */
  controls?: boolean;
  /** Poster image URL for video tag */
  poster?: string;
  /** Title for accessibility */
  title?: string;
}

export interface EmbedSnippets {
  /** HTML5 video tag embed */
  videoTag: string;
  /** Iframe embed (for hosted videos) */
  iframe: string;
  /** Markdown image/video link */
  markdown: string;
  /** GitHub-flavored markdown with video */
  githubMarkdown: string;
}

/**
 * Generate embed snippets for a video file
 */
export function generateEmbedSnippets(
  videoPath: string,
  options: EmbedOptions = {}
): EmbedSnippets {
  const {
    width = '100%',
    height,
    autoplay = false,
    loop = false,
    muted = autoplay, // Auto-mute if autoplay (required by browsers)
    controls = true,
    poster,
    title,
  } = options;

  const filename = path.basename(videoPath);
  const videoTitle = title || filename.replace(/\.[^.]+$/, '');

  // Build video tag
  const videoTag = buildVideoTag(videoPath, {
    width,
    height,
    autoplay,
    loop,
    muted,
    controls,
    poster,
    title: videoTitle,
  });

  // Build iframe (assumes video will be hosted)
  const iframe = buildIframe(videoPath, {
    width,
    height: height || 400,
    title: videoTitle,
  });

  // Build markdown
  const markdown = buildMarkdownEmbed(videoPath, videoTitle);

  // Build GitHub-flavored markdown (uses video tag in HTML block)
  const githubMarkdown = buildGitHubMarkdown(videoPath, videoTitle, poster);

  return {
    videoTag,
    iframe,
    markdown,
    githubMarkdown,
  };
}

/**
 * Generate embed snippets and save to a file
 */
export async function generateEmbedFile(
  videoPath: string,
  outputPath?: string,
  options: EmbedOptions = {}
): Promise<string> {
  const snippets = generateEmbedSnippets(videoPath, options);
  const filename = path.basename(videoPath).replace(/\.[^.]+$/, '');

  const content = `# Embed Snippets for ${filename}

## HTML5 Video Tag

Use this for self-hosted videos on your website:

\`\`\`html
${snippets.videoTag}
\`\`\`

## Iframe Embed

Use this for embedding hosted videos (update the src URL):

\`\`\`html
${snippets.iframe}
\`\`\`

## Markdown

For documentation or README files:

\`\`\`markdown
${snippets.markdown}
\`\`\`

## GitHub README

GitHub renders video tags in README.md. Use this format:

\`\`\`html
${snippets.githubMarkdown}
\`\`\`

---

*Generated by [demo-recorder](https://github.com/neonwatty/demo-recorder)*
`;

  const embedPath = outputPath || videoPath.replace(/\.[^.]+$/, '-embed.md');
  await fs.writeFile(embedPath, content, 'utf-8');

  return embedPath;
}

/**
 * Build HTML5 video tag
 */
function buildVideoTag(src: string, options: {
  width: string | number;
  height?: string | number;
  autoplay: boolean;
  loop: boolean;
  muted: boolean;
  controls: boolean;
  poster?: string;
  title: string;
}): string {
  const attrs: string[] = [];

  // Source
  attrs.push(`src="${escapeAttr(src)}"`);

  // Dimensions
  const widthVal = typeof options.width === 'number' ? `${options.width}px` : options.width;
  attrs.push(`width="${escapeAttr(widthVal)}"`);

  if (options.height) {
    const heightVal = typeof options.height === 'number' ? `${options.height}px` : options.height;
    attrs.push(`height="${escapeAttr(heightVal)}"`);
  }

  // Boolean attributes
  if (options.autoplay) attrs.push('autoplay');
  if (options.loop) attrs.push('loop');
  if (options.muted) attrs.push('muted');
  if (options.controls) attrs.push('controls');
  if (options.autoplay) attrs.push('playsinline'); // Required for mobile autoplay

  // Optional attributes
  if (options.poster) {
    attrs.push(`poster="${escapeAttr(options.poster)}"`);
  }
  attrs.push(`title="${escapeAttr(options.title)}"`);

  return `<video ${attrs.join(' ')}>\n  Your browser does not support the video tag.\n</video>`;
}

/**
 * Build iframe embed
 */
function buildIframe(src: string, options: {
  width: string | number;
  height: string | number;
  title: string;
}): string {
  const widthVal = typeof options.width === 'number' ? options.width : `"${options.width}"`;
  const heightVal = typeof options.height === 'number' ? options.height : `"${options.height}"`;

  return `<iframe
  src="${escapeAttr(src)}"
  width=${widthVal}
  height=${heightVal}
  frameborder="0"
  allowfullscreen
  title="${escapeAttr(options.title)}"
></iframe>`;
}

/**
 * Build markdown embed
 */
function buildMarkdownEmbed(src: string, title: string): string {
  // Standard markdown doesn't support video, so we use a linked thumbnail approach
  return `[![${title}](${src})](${src})`;
}

/**
 * Build GitHub-flavored markdown with video support
 */
function buildGitHubMarkdown(src: string, title: string, poster?: string): string {
  // GitHub README supports video tags directly
  const attrs = [`src="${src}"`, `title="${title}"`];
  if (poster) {
    attrs.push(`poster="${poster}"`);
  }
  return `<video ${attrs.join(' ')} controls>\n  Your browser does not support the video tag.\n</video>`;
}

/**
 * Escape HTML attribute value
 */
function escapeAttr(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}
